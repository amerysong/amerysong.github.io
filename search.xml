<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[概念(Concept)]]></title>
    <url>%2F2019%2F04%2F30%2Fconcepts%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标准库实用工具]]></title>
    <url>%2F2019%2F04%2F30%2Fstandard-type-utilities%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[重载解析]]></title>
    <url>%2F2019%2F04%2F30%2Foverload-resolution%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[值类别]]></title>
    <url>%2F2019%2F04%2F30%2Fvalue-catgories%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一处定义原则]]></title>
    <url>%2F2019%2F04%2F30%2Fthe-one-def-rule%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[调试模板]]></title>
    <url>%2F2019%2F04%2F30%2Fdebugging-templates%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[表达式模板]]></title>
    <url>%2F2019%2F04%2F30%2Fexpression-templates%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[可识别的联合体]]></title>
    <url>%2F2019%2F04%2F30%2Fdiscriminated-unions%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[元组]]></title>
    <url>%2F2019%2F04%2F30%2Ftuples%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Typelist]]></title>
    <url>%2F2019%2F04%2F30%2Ftypelist%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[元编程]]></title>
    <url>%2F2019%2F04%2F30%2Fmetaprogramming%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[桥接静态与动态多态]]></title>
    <url>%2F2019%2F04%2F30%2Fbridging-static-and-dync%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板与继承]]></title>
    <url>%2F2019%2F04%2F30%2Ftemplates-and-inheritance%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[类型属性上的重载]]></title>
    <url>%2F2019%2F04%2F30%2Foverloading-on-type-prop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Traits实现]]></title>
    <url>%2F2019%2F04%2F30%2Fimplementating-traits%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板多态性]]></title>
    <url>%2F2019%2F04%2F30%2Fpolymophic-templates%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板未来发展方向]]></title>
    <url>%2F2019%2F04%2F30%2Ffuture%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板特化与重载]]></title>
    <url>%2F2019%2F04%2F30%2Fspecialization-and-overloading%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板参数推导]]></title>
    <url>%2F2019%2F04%2F30%2Ftemplate-argument-deduction%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[实例化]]></title>
    <url>%2F2019%2F04%2F30%2Finstantiation%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板中的名称]]></title>
    <url>%2F2019%2F04%2F30%2Fnames-in-templates%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[深入模板基础]]></title>
    <url>%2F2019%2F04%2F30%2Ffundamentals-in-depth%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[泛型库]]></title>
    <url>%2F2019%2F04%2F30%2Fgeneric-libraries%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[基本模板术语]]></title>
    <url>%2F2019%2F04%2F30%2Fterminology%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[模板实战]]></title>
    <url>%2F2019%2F04%2F30%2Ftemplate-in-practice%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[编译时编程]]></title>
    <url>%2F2019%2F04%2F30%2Fcompile-time-programming%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[按值传递与按引用传递]]></title>
    <url>%2F2019%2F04%2F30%2Fpass-by-value-or-ref%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[移动语义与enable_if]]></title>
    <url>%2F2019%2F04%2F30%2Fmove-semantics-and-enable-if%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[基础模板技术]]></title>
    <url>%2F2019%2F04%2F30%2Ftricky-basics%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[可变参数模板]]></title>
    <url>%2F2019%2F04%2F30%2Fvariadic-templates%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[非类型模板参数]]></title>
    <url>%2F2019%2F04%2F30%2Fnonetype-template-parameters%2F</url>
    <content type="text"></content>
      <categories>
        <category>cs</category>
        <category>lang</category>
        <category>cpp</category>
        <category>cpp templates:the complete guide</category>
      </categories>
      <tags>
        <tag>cs</tag>
        <tag>lang</tag>
        <tag>cpp</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类模板]]></title>
    <url>%2F2019%2F04%2F30%2Fclass-template%2F</url>
    <content type="text"></content>
      <categories>
        <category>cs</category>
        <category>lang</category>
        <category>cpp</category>
        <category>cpp templates:the complete guide</category>
      </categories>
      <tags>
        <tag>cs</tag>
        <tag>lang</tag>
        <tag>cpp</tag>
        <tag>template</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数模板]]></title>
    <url>%2F2019%2F04%2F29%2Ffunction-template%2F</url>
    <content type="text"><![CDATA[初识函数模板定义函数模板函数模板是参数化的函数，是一系列功能相同的函数的抽象，你可以使用不同的模板参数来调用它。如下是一个返回两个值中最大值的模板函数： 12345template &lt;typename T&gt;T max (T a, T b)&#123; return b &lt; a? a : b;&#125; 该模板函数定义了一系列返回两个值中最大值的函数，其参数a和b的类型由模板参数T指定。模板函数必须使用关键字template声明，模板参数位于&lt;&gt;中，以逗号分隔，如下所示： template 在我们的例子中，参数列表为typename T，其中，关键字typename引入类型参数，T为引入的类型参数，由调用者决定其具体类型，这里的类型参数T可以使用任何字母代替，这是目前C++程序中最常见的模板参数，但是其他参数也是允许的，参考 非类型模板参数 一节了解更多信息。这个例子中，类型T必须支持&lt;操作符，因为代码中a和b的比较使用了它，同时，类型T必须是可复制的，因为函数返回了它。 由于历史的原因，定义类型参数时你也可以使用class关键字来代替typename，typename关键字是C++98之后的标准引入的，在此之前，只能使用class来引入类型参数。因此，max()函数也可以使用以下的方式定义： 12345template &lt;class T&gt;T max(T a, T b)&#123; return b &lt; a? a : b;&#125; 在此上下文中，两种定义方式没有区别，但是class关键字可能会误导你认为这里T必须为一个类，因此建议使用typename以避免误导。 使用模板以下程序展示了如何使用max()模板函数： 1234567891011121314151617#include "max1.hpp"#include &lt;iostream&gt;#include &lt;string&gt;int main()&#123; int i = 42; std::cout &lt;&lt; "max(7, i):" &lt;&lt; ::max(7, i) &lt;&lt; std::endl; double f1 = 3.4; double f2 = 5.9; std::cout &lt;&lt; "max(f1, f2):" &lt;&lt; ::max(f1, f2) &lt;&lt; std::endl; std::string s1 = "chinese"; std::string s2 = "english"; std::cout &lt;&lt; "max(s1, s2):" &lt;&lt; ::max(s1, s2) &lt;&lt; std::endl;&#125; 程序中分别使用int、double和std::string三种类型的变量调用了三次max()函数，程序输出如下： max(7, i):42max(f1, f2):5.9max(s1, s2):english max()函数调用时使用::来确保调用的是我们自己实现的函数而非标准库中的std::max()。编译器会根据模板函数的调用情况，分别为不同的类型生成相应的函数，我们的代码使用三种类型来调用max()函数，因此编译器会分别为三个类型分别生成相应的函数，即我们的调用生成了以下三个函数： 123int max(int a, int b);double max(double a, double b);std::string max(std::string a, std::string b); 将类型参数（T）替换为实际类型（int、double、std::string）的过程称为模板实例化。 模板两阶段翻译如果模板实例化使用的函数参数不支持模板函数体内的运算，这将会导致编译错误，例如以下代码将会编译出错： 12345678#include "max1.hpp"#include &lt;complex&gt;int main()&#123; std::complex&lt;float&gt; c1, c2; // std::complex不支持“&lt;”运算 ::max(c1, c2); return 0;&#125; 因此模板的编译过程分为两个阶段： 在模板代码未实例化的定义期，对模板代码在忽略模板参数的前提下进行检查，这些检查包括： 检查语法错误，如缺少分号 使用不依赖模板参数的未知名称会被发现 不依赖模板参数的静态断言会被检查 在实例化阶段，模板代码会被再次检查以确保所有代码的合法性。也就是说，所有依赖模板参数的部分会被二次检查。 例如，以下代码： 12345678template &lt;typename T&gt;void foo(T t)&#123; undeclared(); // 第一阶段编译错误，如果undeclared()未知 undeclared(t); // 第二阶段编译错误，如果undeclared(T)未知 static_assert(sizeof(int) &gt; 10, "int too small"); // 总是编译错误 static_assert(sizeof(T) &gt; 10, "T to small"); //如果T小于10，编译错误 &#125; 注意，一些编译器在第一阶段不会作全面检查，因此，在第二阶段前你不会马上看到编译错误。参考 模板实例化 一节了解更多模板实例化内容。同时，两阶段翻译会导致一些问题：当函数模板以触发实例化的方式使用（使用模板参数和函数参数调用）时，编译器需要知道模板定义。这将会打破普通函数通常意义上的编译和链接的界限，因为编译器只需要知道普通函数的声明即可正确编译程序，参考 模板实例化 一节了解更多关于该问题的内容。 模板参数推导当我们使用一些参数调用模板函数的时候，如max()，模板参数类型由我们传递的函数参数决定。如果我们传递两个int类型的函数参数，C++编译器将模板参数类型T推导为int。然而，T也能是函数参数类型的部分类型，如果我们这样定义max()函数： 12345template &lt;typename T&gt;T max(T const&amp; a, T const&amp; b)&#123; return b &lt; a ？ a : b;&#125; 当我们传递的函数参数为int时，T同样被推导为int类型，而非int const&amp;类型。 在类型推导时，自动类型转换收到限制： 当模板函数的函数参数为引用时，即便是微小的类型转换也不会在类型推导中应用。以模板参数修饰的两个函数参数类型必须一致 当模板函数的函数参数为值是，模板推导时部分类型会退化：const和volatile会被忽略，引用退化为引用的类型，原始数组或函数退化为相应的指针类型，以模板参数修饰的两个函数参数，其退化后的类型必须一致 以代码解释如下： 123456789101112template &lt;typename T&gt;T max(T a, T b);...int const c = 42;max(i, c); // T被推导为intint&amp; ir = i;max(i, ir); // T被推导为intint arr[4];foo(&amp;i, arr); // T被推导为int*max(4, 7.2); // 错误，T无法被推导为两个类型: int, doublestd::string s;foo("hello", s);// 错误，T无法推导为两个类型: cosnt char[6], std::string 此类错误可以使用以下解决方案： 对参数类型进行转换：max(static_cast&lt;double&gt;(4), 7.2) 具体指定T的类型：max&lt;double&gt;(4, 7.2) 具体说明模板参数可能有不同类型，参考模板参数推导 一节了解更多 需要注意的是，模板参数推导无法工作于默认函数参数，如： 12345template &lt;typename T&gt;void f(T = "");f(1); // 正确，T被推导为intf(); // 错误，无法推导T 为了支持这种情况，你需要为模板参数声明一个默认的函数参数，参考本文默认模板参数了解更多。 多模板参数我们已经看到，函数模板有两种类型的参数： 模板参数，声明于函数模板前的&lt;&gt;中的参数，即上文提到的T 函数参数，声明于函数模板()中的参数 你可以拥有任意模板参数，比如，你可以使用如下方式定义max()函数： 12345template&lt;typename T1, template T2&gt;T1 max(T1 a, T2 b)&#123; return b &lt; a ？ a : b;&#125; 此时，第一个模板参数定义了返回值类型，但是这会导致一个问题：函数内部会将其他类型转换为返回类型，因此函数调用时参数的顺序会影响返回值类型，如使用66.66和42调用会得到66.66，使用42和66.66调用会得到66。C++提供了多种解决这个问题的方法： 引入第三个模板参数用于返回值类型 让编译器自动找出返回值类型 将返回值类型定义为两个参数的“公共类型” 返回值类型模板参数模板函数调用时，我们可以指明模板参数的具体类型，但是模板参数推导允许我们在模板函数调用时不指明模板参数的具体类型。在模板函数参数与模板参数没有联系的情况下，你必须显式为模板参数指明具体类型。比如你可以为max()函数定义第三个参数用于返回值： 12template&lt;typename T2, typename T2, typename TR&gt;TR max(T1 a, T2 b); 此时，由于模板参数推导不会考虑返回值，且TR与函数调用参数无关，因此，无法自动推导RT的具体类型，必须显式指定： 1::max&lt;int, double, double&gt;(4, 7.2); 你也可以仅指定返回值TR的具体类型，T1和T2的具体类型可由编译器自动推导： 1::max&lt;double&gt;(4, 7.2); 返回值类型推导如果返回值取决于模板参数，最简单的方式是让编译器推导它的类型，C++14以后，使用auto关键词就能完成这个任务： 12345template&lt;typename T1, typename T2&gt;auto max(T1 a, T2 b)&#123; return b &lt; a ？ a : b; &#125; 上述代码使用了auto，但是没有返回类型后置，这表明实际的返回类型必须从函数体内的return语句推导。 默认模板参数补充材料返回类型后置C++11引入了可以将返回值使用-&gt;声明在函数名后的新语法，称为返回类型后置，例如： 1auto add(int x, int y) -&gt; int; 这种情况下，auto不会进行类型推导，而是语法的一部分。返回值类型后置解决了函数模板定义时依赖于模板参数的返回类型无法泛化的问题。比如，函数模板： 12345template&lt;typename A, typename B&gt;ReturnType multiply(cosnt A&amp; a, const B &amp;b)&#123; return a * b;&#125; 在没有返回值类型后置特习的情况下，你无法为multiply模板函数泛化所有的返回值类型（即a*b的所有类型），而有了返回值类型后置，你就可以完美解决这个问题： 12345template&lt;typename A, typename B&gt;auto multiply(cosnt A&amp; a, const B &amp;b) -&gt; decltype(a*b)&#123; return a * b ;&#125; 参考资料： https://www.learncpp.com/cpp-tutorial/4-8-the-auto-keyword/ https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/trailing_return.htm]]></content>
      <categories>
        <category>cs</category>
        <category>lang</category>
        <category>cpp</category>
        <category>cpp templates:the complete guide</category>
      </categories>
      <tags>
        <tag>cs</tag>
        <tag>lang</tag>
        <tag>cpp</tag>
        <tag>template</tag>
      </tags>
  </entry>
</search>
